# -*- coding: utf-8 -*-
"""OFDM-BASED JOINT COMMUNICATION & SENSING SIMULATOR — PYTHON.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pCoF3MtT0mAo3MvgPc4zvKQD2HTGmAr_
"""

!pip install numpy matplotlib

import numpy as np

# ----------------------------
# QPSK Modulation Function
# ----------------------------
def qpsk_mod(bits):
    # Reshape bit stream into pairs (since QPSK = 2 bits per symbol)
    bits = bits.reshape(-1, 2)

    # Gray-coded QPSK mapping table
    mapping = {
        (0,0): 1 + 1j,
        (0,1): -1 + 1j,
        (1,1): -1 - 1j,
        (1,0): 1 - 1j
    }

    # Convert bit pairs into complex QPSK symbols
    symbols = np.array([mapping[tuple(b)] for b in bits]) / np.sqrt(2)

    return symbols


# ----------------------------
# OFDM Transmitter
# ----------------------------
def ofdm_tx(bit_stream, n_subcarriers=64, cp_len=16):

    bits_per_symbol = 2  # QPSK = 2 bits per subcarrier
    bits_per_ofdm_symbol = n_subcarriers * bits_per_symbol

    # Number of OFDM symbols we will transmit
    num_ofdm_symbols = len(bit_stream) // bits_per_ofdm_symbol

    tx = []  # container for OFDM time-domain symbols

    for i in range(num_ofdm_symbols):
        # Extract bits belonging to one OFDM symbol
        bits = bit_stream[i*bits_per_ofdm_symbol:(i+1)*bits_per_ofdm_symbol]

        # QPSK modulation
        qsymbols = qpsk_mod(bits)

        # IFFT converts frequency-domain subcarriers → time-domain
        time = np.fft.ifft(qsymbols)

        # Take last CP samples (cyclic prefix)
        cp = time[-cp_len:]

        # Prepend CP to the beginning of the OFDM symbol
        tx_symbol = np.concatenate([cp, time])

        tx.append(tx_symbol)

    # Return full transmit signal and number of symbols
    return np.concatenate(tx), num_ofdm_symbols

import numpy as np

# ----------------------------
# Add AWGN Noise
# ----------------------------
def awgn(signal, snr_db):

    # Calculate average signal power
    sig_power = np.mean(np.abs(signal) ** 2)

    # Convert SNR from dB → linear scale
    snr_linear = 10 ** (snr_db / 10.0)

    # Calculate noise power needed to achieve the SNR
    noise_power = sig_power / snr_linear

    # Create complex Gaussian noise
    noise = np.sqrt(noise_power / 2) * (
        np.random.randn(*signal.shape) + 1j * np.random.randn(*signal.shape)
    )

    return signal + noise


# ----------------------------
# Simple Multipath Fading
# ----------------------------
def multipath(signal, taps=[(0, 1.0)]):

    # Find maximum delay among taps
    max_delay = max([d for d, a in taps])

    # Create channel impulse response
    h = np.zeros(max_delay + 1, dtype=complex)

    # Assign amplitude values to delayed taps
    for d, a in taps:
        h[d] = a

    # Convolve signal with channel impulse response
    return np.convolve(signal, h), h


# ----------------------------
# Add Target Reflection (for sensing)
# ----------------------------
def apply_target_impulse(signal, target_delay_samples=40, target_amp=0.8):

    # Create two-tap multipath:
    # tap 1 → direct path
    # tap 2 → reflected delayed path
    return multipath(signal, taps=[
        (0, 1.0),                     # Direct signal (no delay)
        (target_delay_samples, target_amp)  # Target reflection
    ])

import numpy as np

# ----------------------------
# OFDM Receiver
# ----------------------------
def ofdm_rx(rx_signal, n_subcarriers=64, cp_len=16, num_ofdm_symbols=1):

    symbols = []
    idx = 0  # pointer inside received signal

    for _ in range(num_ofdm_symbols):

        # Extract one OFDM symbol with cyclic prefix
        symbol = rx_signal[idx:idx + n_subcarriers + cp_len]
        idx += n_subcarriers + cp_len

        # Remove cyclic prefix
        symbol = symbol[cp_len:]

        # FFT converts time → frequency domain
        freq = np.fft.fft(symbol)

        symbols.append(freq)

    return np.concatenate(symbols)


# ----------------------------
# QPSK Hard Decision Demodulator
# ----------------------------
def qpsk_demod(symbols):

    bits = []

    for s in symbols:
        re, im = s.real, s.imag

        # Decide quadrant → bits
        if re >= 0 and im >= 0:
            bits += [0,0]
        elif re < 0 and im >= 0:
            bits += [0,1]
        elif re < 0 and im < 0:
            bits += [1,1]
        else:
            bits += [1,0]

    return np.array(bits, dtype=int)

import numpy as np

# ----------------------------
# Delay Estimation via Cross-Correlation
# ----------------------------
def estimate_delay(rx_pref, tx_pref):

    # Cross-correlation measures similarity at different time shifts
    corr = np.abs(np.correlate(rx_pref, tx_pref, mode='full'))

    # Find peak → strongest match → estimated delay
    peak_idx = np.argmax(corr)

    # Convert correlation index to delay in samples
    lag = peak_idx - (len(tx_pref) - 1)

    return lag, corr

def bits_random(n):
    return np.random.randint(0, 2, n) # random bit generator

import numpy as np
import matplotlib.pyplot as plt

# -----------------------------------------
# BER vs SNR Simulation
# -----------------------------------------
def ber_vs_snr(snr_list_db):

    n_subcarriers = 64
    cp_len = 16
    bits_per_ofdm = n_subcarriers * 2  # QPSK → 2 bits per subcarrier
    n_symbols = 50  # number of OFDM symbols to transmit

    # Generate random bits
    bits = bits_random(bits_per_ofdm * n_symbols)

    # Transmit OFDM signal
    tx_signal, num_ofdm = ofdm_tx(bits, n_subcarriers, cp_len)

    bers = []

    for snr in snr_list_db:

        # Pass signal through AWGN channel
        rx = awgn(tx_signal, snr)

        # OFDM demodulation
        rx_syms = ofdm_rx(rx, n_subcarriers, cp_len, num_ofdm)

        # QPSK demodulation
        rx_bits = qpsk_demod(rx_syms)

        # Clip to correct length
        rx_bits = rx_bits[:len(bits)]

        # Calculate BER
        ber = np.mean(rx_bits != bits)

        bers.append(ber)

    # Plot BER curve
    plt.figure()
    plt.semilogy(snr_list_db, bers, marker='o')
    plt.grid(True)
    plt.xlabel("SNR (dB)")
    plt.ylabel("BER")
    plt.title("BER vs SNR (OFDM QPSK)")
    plt.show()

    return snr_list_db, bers



# -----------------------------------------
# Sensing (Radar-Like Delay Estimation)
# -----------------------------------------
def sensing_demo():

    n_subcarriers = 64
    cp_len = 16
    bits_per_ofdm = n_subcarriers * 2

    # Generate one OFDM symbol
    bits = bits_random(bits_per_ofdm)
    tx_symbol, _ = ofdm_tx(bits, n_subcarriers, cp_len)

    # Extract one OFDM time-domain symbol (with CP)
    tx_pref = tx_symbol[:n_subcarriers + cp_len]

    # True delay of the reflected target (samples)
    true_delay = 40

    # Add reflection of the signal at 'true_delay'
    rx_with_target, _ = apply_target_impulse(tx_pref, target_delay_samples=true_delay)

    # Estimate time delay using cross-correlation
    est_delay, corr = estimate_delay(rx_with_target, tx_pref)

    # Generate lag axis for plotting correlation
    lags = np.arange(len(corr)) - (len(tx_pref) - 1)

    # Plot correlation
    plt.figure()
    plt.plot(lags, corr)
    plt.grid(True)
    plt.xlabel("Lag (samples)")
    plt.ylabel("Correlation magnitude")
    plt.title(f"Delay Estimation (True={true_delay}, Estimated={est_delay})")
    plt.show()

    return true_delay, est_delay



# -----------------------------------------
# RUN BOTH SIMULATIONS
# -----------------------------------------
snrs = [0, 5, 10, 15, 20]
snr_list, bers = ber_vs_snr(snrs)

true_delay, est_delay = sensing_demo()

print("BER results:", list(zip(snr_list, bers)))
print("True delay:", true_delay, "Estimated delay:", est_delay)

